<!DOCTYPE html>
<html>

<head>
  <link rel="stylesheet" href="css/shared.css">
  <link rel="stylesheet" href="css/overlay.css">
</head>

<body>
  <div id="app">
    <div id="drag-bar" title="Drag to Move">
      <div style="display:flex;align-items:center;gap:10px">
        <div class="grip"><span></span><span></span><span></span></div>
        <span title="Drag to Move">Chat on Everything</span>
      </div>
      <div style="display:flex;gap:8px">
        <button id="passiveBtn" class="bar-btn" title="Immersive Mode Ctrl+Alt+K">üëÅ</button>
        <button id="settingsBtn" class="bar-btn" title="Settings">‚öô</button>
        <button id="closeBtn" class="bar-btn" title="End Session">‚úï</button>
      </div>
    </div>

    <div id="messages"></div>
    <div id="join-text">Join Chat on Everything: <span id="session-code">ABC123</span></div>

    <!-- QR Code Overlay -->
    <div id="qr-overlay">
      <div class="qr-main-title">Chat on Everything</div>
      <img id="qr-image" src="" alt="QR Code">
      <div class="qr-title">Scan to Join</div>
      <div class="qr-url" id="qr-url"></div>
      <button class="qr-back-btn" id="qr-back-btn">Continue</button>
    </div>

    <!-- Resize edges -->
    <div class="resize-edge top" data-dir="n"></div>
    <div class="resize-edge bottom" data-dir="s"></div>
    <div class="resize-edge left" data-dir="w"></div>
    <div class="resize-edge right" data-dir="e"></div>
    <div class="resize-edge top-left" data-dir="nw"></div>
    <div class="resize-edge top-right" data-dir="ne"></div>
    <div class="resize-edge bottom-left" data-dir="sw"></div>
    <div class="resize-edge bottom-right" data-dir="se"></div>

    <div id="settings-backdrop"></div>
    <div id="settings">
      <div id="settings-scroll">
        <h3>
          Settings
          <button class="close-settings">‚úï</button>
        </h3>

        <!-- Session Info Section -->
        <div style="font:500 12px 'Outfit',sans-serif;color:var(--accent);margin:4px 0 12px 0;">
          Session Details
        </div>
        <div style="margin-bottom:20px;padding-bottom:16px;border-bottom:1px solid var(--border)">
          <label>Mobile URL</label>
          <a style="font:500 11px 'JetBrains Mono',monospace;margin:4px 0 12px 0;word-break:break-all;display:block"
            class="settings-link" id="mobile-url" href="#">Loading...</a>

          <label>Admin URL</label>
          <a style="font:500 11px 'JetBrains Mono',monospace;margin:4px 0 12px 0;word-break:break-all;display:block"
            class="settings-link" id="admin-url" href="#">Loading...</a>

          <label>Admin Password</label>
          <div class="password-row">
            <div class="password-input-wrap">
              <input id="admin-password" type="password" value="--------" readonly aria-label="Admin password">
              <button id="admin-password-copy" type="button" aria-label="Copy admin password" title="Copy">üìã</button>
            </div>
            <button id="admin-password-toggle" type="button" aria-label="Show admin password">Show</button>
          </div>

          <label>Hotkey</label>
          <div style="font:600 11px 'JetBrains Mono',monospace;color:var(--accent);margin:4px 0 12px 0"
            id="hotkey-value">Ctrl+Alt+K</div>
          <label>Support</label>
          <div style="font:600 11px 'JetBrains Mono',monospace;color:var(--accent);margin:4px 0 12px 0"
            id="support-value">Sumedh Supe</div>
        </div>

        <!-- Display Settings -->
        <label style="margin-top:0">
          <input type="checkbox" id="hideIp" style="margin-right:8px;accent-color:var(--accent)">
          Hide IP
        </label>

        <label style="margin-top:16px">Max Messages</label>
        <div class="setting-row">
          <input type="range" id="maxMsgSlider" min="2" max="10" value="5">
          <span class="value" id="maxMsgValue">5</span>
        </div>

        <label style="margin-top:16px">Font Size</label>
        <div class="setting-row">
          <input type="range" id="fontSizeSlider" min="10" max="48" value="13">
          <span class="value" id="fontSizeValue">13</span>
        </div>

        <label style="margin-top:16px">
          <input type="checkbox" id="showJoinCode" style="margin-right:8px;accent-color:var(--accent)">
          Show Join Code
        </label>

        <label style="margin-top:12px">
          <input type="checkbox" id="showMobileLink" style="margin-right:8px;accent-color:var(--accent)">
          Show QR Code
        </label>

        <label style="margin-top:12px">
          <input type="checkbox" id="disableChatHistory" checked style="margin-right:8px;accent-color:var(--accent)">
          Disable Chat History for Others
        </label>

        <label style="margin-top:12px">
          <input type="checkbox" id="enableFeedbackForm" style="margin-right:8px;accent-color:var(--accent)">
          Enable Feedback Form
        </label>

        <label style="margin-top:12px">
          <input type="checkbox" id="emojiDirectSend" checked style="margin-right:8px;accent-color:var(--accent)">
          Emoji Direct to Send
        </label>

        <label style="margin-top:12px">
          <input type="checkbox" id="slowModeEnabled" style="margin-right:8px;accent-color:var(--accent)">
          Slow Mode
        </label>

        <div id="slowModeSecondsGroup" style="margin-top:12px;display:none">
          <label>Slow Mode Delay (seconds)</label>
          <div class="setting-row">
            <input type="range" id="slowModeSlider" min="1" max="30" value="3">
            <span class="value" id="slowModeValue">3</span>
          </div>
        </div>

        <!-- Remote Control Settings -->
        <div style="margin-top:20px;padding-top:16px;border-top:1px solid var(--border)">
          <div style="font:500 12px 'Outfit',sans-serif;color:var(--accent);margin:4px 0 12px 0;">
            Remote Control
          </div>
          <label style="margin-top:0">
            <input type="checkbox" id="enableRemoteControl" style="margin-right:8px;accent-color:var(--accent)">
            Enable Remote Control
          </label>
          <div style="font:11px 'Outfit',sans-serif;color:var(--text-dim);margin-top:4px">
            Allow controlling mouse, keyboard & media from phone
          </div>
        </div>

        <!-- @Cee AI Agent Settings -->
        <div style="margin-top:20px;padding-top:16px;border-top:1px solid var(--border)">
          <div style="font:500 12px 'Outfit',sans-serif;color:var(--accent);margin:4px 0 12px 0;">
            @Cee AI Agent
          </div>
          <label style="margin-top:0">
            <input type="checkbox" id="enableCeeAgent" style="margin-right:8px;accent-color:var(--accent)">
            Enable @Cee Agent
          </label>

          <div id="ceeApiKeyGroup" style="margin-top:12px;display:none">
            <label>API Provider</label>
            <select id="ceeApiProvider"
              style="width:100%;padding:10px;border-radius:10px;border:1px solid var(--border);background:#1a1a2e;color:var(--text);font:500 13px 'Outfit',sans-serif;outline:none;margin-bottom:12px;cursor:pointer">
              <option value="openai">OpenAI</option>
              <option value="gemini">Gemini</option>
            </select>
            <label id="ceeApiKeyLabel">OpenAI API Key</label>
            <div class="password-row">
              <div class="password-input-wrap">
                <input id="cee-api-key" type="password" value="" placeholder="sk-..." aria-label="API Key" tabindex="0">
                <button id="cee-api-key-copy" type="button" aria-label="Copy API key" title="Copy">üìã</button>
              </div>
              <button id="cee-api-key-toggle" type="button" aria-label="Show API key">Show</button>
            </div>
            <div id="ceeApiKeyStatus"
              style="font:600 11px 'JetBrains Mono',monospace;color:var(--danger);margin:4px 0 8px 0;padding:8px 10px;border-radius:8px;background:rgba(255,255,255,0.03);border:1px solid var(--border)">
              Not Set
            </div>
            <label style="margin-top:12px">Custom Instructions (optional)</label>
            <textarea id="ceeSystemPrompt" rows="2" maxlength="300"
              placeholder="e.g., be like Darth Vader, answer in 10 words only, talk like Yoda..."></textarea>
            <div style="font:11px 'Outfit',sans-serif;color:var(--text-dim);margin-top:4px">Customize Cee's personality
              or response style</div>
          </div>
        </div>
      </div>
      <div id="settings-scrollbar" aria-hidden="true">
        <div id="settings-scroll-thumb"></div>
      </div>
    </div>

    <div id="confirm-backdrop"></div>
    <div id="confirm-dialog">
      <p>Are you sure you want to<br>end the session?</p>
      <div class="btn-row">
        <button class="cancel-btn">Cancel</button>
        <button class="confirm-btn">End Session</button>
      </div>
    </div>

    <div id="mode">ACTIVE</div>
  </div>

  <script>
    const { ipcRenderer, shell, clipboard } = require('electron');

    const $ = id => document.getElementById(id);
    const app = $('app'), dragBar = $('drag-bar');
    const messages = $('messages'), mode = $('mode');

    let dragging = false, resizing = false, resizeDir = '';
    let lastX = 0, lastY = 0;
    let startX = 0, startY = 0, startW = 0, startH = 0, startPosX = 0, startPosY = 0;

    // Drag
    dragBar.onmousedown = e => {
      if (e.target.id === 'closeBtn') return;
      dragging = true;
      lastX = e.screenX; lastY = e.screenY;
    };

    // Resize from any edge
    document.querySelectorAll('.resize-edge').forEach(edge => {
      edge.onmousedown = async e => {
        resizing = true;
        resizeDir = edge.dataset.dir;
        const b = await ipcRenderer.invoke('get-window-bounds');
        startX = e.screenX; startY = e.screenY;
        startW = b.width; startH = b.height;
        startPosX = b.x; startPosY = b.y;
        e.preventDefault();
      };
    });

    document.onmousemove = e => {
      if (dragging) {
        ipcRenderer.send('window-move', { deltaX: e.screenX - lastX, deltaY: e.screenY - lastY });
        lastX = e.screenX; lastY = e.screenY;
      }
      if (resizing) {
        const dx = e.screenX - startX;
        const dy = e.screenY - startY;
        let x, y, w = startW, h = startH;

        // Handle each direction
        if (resizeDir.includes('e')) w = startW + dx;
        if (resizeDir.includes('w')) { w = startW - dx; x = startPosX + dx; }
        if (resizeDir.includes('s')) h = startH + dy;
        if (resizeDir.includes('n')) { h = startH - dy; y = startPosY + dy; }

        ipcRenderer.send('window-resize', { width: w, height: h, x, y });
      }
    };

    document.onmouseup = () => { dragging = false; resizing = false; resizeDir = ''; };

    // Mode toggle
    ipcRenderer.on('mode-change', (_, m) => {
      mode.textContent = m.toUpperCase();
      mode.classList.add('show');
      app.classList.toggle('active', m === 'active');
      if (m === 'passive') {
        closeSettings();
        setTimeout(() => mode.classList.remove('show'), 2000);
      }
    });

    // Enter passive mode
    $('passiveBtn').onclick = () => ipcRenderer.send('enter-passive');

    // Close app with confirmation
    const confirmDialog = $('confirm-dialog');
    const confirmBackdrop = $('confirm-backdrop');

    function showConfirm() {
      confirmDialog.classList.add('open');
      confirmBackdrop.classList.add('open');
    }

    function hideConfirm() {
      confirmDialog.classList.remove('open');
      confirmBackdrop.classList.remove('open');
    }

    $('closeBtn').onclick = showConfirm;
    confirmBackdrop.onclick = hideConfirm;
    confirmDialog.querySelector('.cancel-btn').onclick = hideConfirm;
    confirmDialog.querySelector('.confirm-btn').onclick = () => ipcRenderer.send('close-app');

    // Settings menu
    const settings = $('settings');
    const settingsBackdrop = $('settings-backdrop');
    const settingsScroll = $('settings-scroll');
    const settingsScrollBar = $('settings-scrollbar');
    const settingsScrollThumb = $('settings-scroll-thumb');
    let settingsThumbDrag = null;

    function updateSettingsThumb() {
      if (!settingsScroll || !settingsScrollBar || !settingsScrollThumb) return;
      const ch = settingsScroll.clientHeight;
      const sh = settingsScroll.scrollHeight;
      const trackH = settingsScrollBar.clientHeight;

      // If hidden/not laid out yet, bail.
      if (ch <= 0 || sh <= 0 || trackH <= 0) return;

      // No scrolling needed -> hide custom thumb.
      if (sh <= ch + 1) {
        settingsScrollBar.style.display = 'none';
        return;
      }

      settingsScrollBar.style.display = 'block';

      // Make the thumb intentionally shorter (UX preference), but keep it usable.
      const thumbScale = 0.75;
      const minThumb = 18;
      const idealThumb = Math.round(trackH * (ch / sh) * thumbScale);
      const thumbH = Math.max(minThumb, idealThumb);
      const maxTop = Math.max(0, trackH - thumbH);
      const maxScroll = Math.max(1, sh - ch);
      const rawTop = (settingsScroll.scrollTop / maxScroll) * maxTop;
      const top = Math.min(maxTop, Math.max(0, rawTop));

      settingsScrollThumb.style.height = `${thumbH}px`;
      settingsScrollThumb.style.transform = `translateY(${top}px)`;
    }

    function openSettings() {
      settings.classList.add('open');
      settingsBackdrop.classList.add('open');
      // Let layout happen before calculating scroll metrics.
      requestAnimationFrame(() => requestAnimationFrame(updateSettingsThumb));
    }

    function closeSettings() {
      settings.classList.remove('open');
      settingsBackdrop.classList.remove('open');
    }

    $('settingsBtn').onclick = openSettings;
    settings.querySelector('.close-settings').onclick = closeSettings;
    settingsBackdrop.onclick = closeSettings;

    // Custom scrollbar wiring (thumb-only)
    if (settingsScroll) {
      settingsScroll.addEventListener('scroll', updateSettingsThumb, { passive: true });
    }

    if (settingsScrollThumb && settingsScroll) {
      settingsScrollThumb.addEventListener('mousedown', (e) => {
        e.preventDefault();
        const ch = settingsScroll.clientHeight;
        const sh = settingsScroll.scrollHeight;
        const thumbH = settingsScrollThumb.getBoundingClientRect().height;
        const trackH = settingsScrollBar ? settingsScrollBar.clientHeight : ch;
        const maxTop = Math.max(1, trackH - thumbH);
        const maxScroll = Math.max(1, sh - ch);

        settingsThumbDrag = {
          startY: e.clientY,
          startScrollTop: settingsScroll.scrollTop,
          pxToScroll: maxScroll / maxTop,
        };
      });
    }

    document.addEventListener('mousemove', (e) => {
      if (!settingsThumbDrag || !settingsScroll) return;
      const dy = e.clientY - settingsThumbDrag.startY;
      settingsScroll.scrollTop = settingsThumbDrag.startScrollTop + (dy * settingsThumbDrag.pxToScroll);
    });

    document.addEventListener('mouseup', () => { settingsThumbDrag = null; });

    // Keep thumb correct if content/size changes.
    if (window.ResizeObserver && settingsScroll) {
      const ro = new ResizeObserver(() => updateSettingsThumb());
      ro.observe(settingsScroll);
    } else {
      window.addEventListener('resize', updateSettingsThumb);
    }

    // Settings
    let maxMessages = 5;
    const maxMsgSlider = $('maxMsgSlider');
    const maxMsgValue = $('maxMsgValue');

    maxMsgSlider.oninput = () => {
      maxMessages = parseInt(maxMsgSlider.value);
      maxMsgValue.textContent = maxMessages;
      trimMessages();
      updateOpacity();
      ipcRenderer.send('settings-changed', { maxMessages });
    };

    // Font size setting
    const fontSizeSlider = $('fontSizeSlider');
    const fontSizeValue = $('fontSizeValue');

    function applyFontSize(size) {
      document.querySelectorAll('.msg').forEach(msg => {
        msg.style.fontSize = size + 'px';
        msg.querySelector('.user').style.fontSize = (size - 2) + 'px';
      });
      messages.dataset.fontSize = size;
    }

    fontSizeSlider.oninput = () => {
      const size = parseInt(fontSizeSlider.value);
      fontSizeValue.textContent = size;
      applyFontSize(size);
      ipcRenderer.send('settings-changed', { fontSize: size });
    };

    // Join code visibility
    const joinText = $('join-text');
    const showJoinCodeCheckbox = $('showJoinCode');
    let showJoinCode = false; // Default to hidden

    function updateJoinTextVisibility() {
      const hasMessages = messages.children.length > 0;
      if (showJoinCode && hasMessages) {
        joinText.classList.add('visible');
      } else {
        joinText.classList.remove('visible');
      }
    }

    showJoinCodeCheckbox.onchange = () => {
      showJoinCode = showJoinCodeCheckbox.checked;
      updateJoinTextVisibility();
      ipcRenderer.send('settings-changed', { showJoinCode });
    };

    // Show QR Code setting
    const showMobileLinkCheckbox = $('showMobileLink');
    const qrOverlay = $('qr-overlay');
    const qrImage = $('qr-image');
    const qrUrlEl = $('qr-url');
    let mobileUrl = '';

    function updateQRDisplay(show) {
      if (show && mobileUrl) {
        const qrApiUrl = `https://api.qrserver.com/v1/create-qr-code/?size=140x140&data=${encodeURIComponent(mobileUrl)}`;
        qrImage.src = qrApiUrl;
        qrUrlEl.textContent = mobileUrl;
        qrOverlay.classList.add('visible');
      } else {
        qrOverlay.classList.remove('visible');
      }
    }

    showMobileLinkCheckbox.onchange = () => {
      updateQRDisplay(showMobileLinkCheckbox.checked);
      ipcRenderer.send('settings-changed', { showMobileLink: showMobileLinkCheckbox.checked });
    };

    // QR back button
    $('qr-back-btn').onclick = () => {
      showMobileLinkCheckbox.checked = false;
      updateQRDisplay(false);
      ipcRenderer.send('settings-changed', { showMobileLink: false });
    };

    // Hide IP setting
    const hideIpCheckbox = $('hideIp');
    if (hideIpCheckbox) {
      hideIpCheckbox.onchange = () => {
        ipcRenderer.send('settings-changed', { hideIp: hideIpCheckbox.checked });
        // Refresh session info to get updated URLs
        initSession().then(() => {
          // Update QR code if it's currently displayed
          if (showMobileLinkCheckbox && showMobileLinkCheckbox.checked) {
            updateQRDisplay(true);
          }
        });
      };
    }

    // Disable chat history setting
    const disableChatHistoryCheckbox = $('disableChatHistory');

    disableChatHistoryCheckbox.onchange = () => {
      ipcRenderer.send('settings-changed', { disableChatHistory: disableChatHistoryCheckbox.checked });
    };

    // Feedback form setting (mobile-only)
    const enableFeedbackFormCheckbox = $('enableFeedbackForm');
    if (enableFeedbackFormCheckbox) {
      enableFeedbackFormCheckbox.onchange = () => {
        ipcRenderer.send('settings-changed', { enableFeedbackForm: enableFeedbackFormCheckbox.checked });
      };
    }

    // Emoji direct send setting
    const emojiDirectSendCheckbox = $('emojiDirectSend');
    if (emojiDirectSendCheckbox) {
      emojiDirectSendCheckbox.onchange = () => {
        ipcRenderer.send('settings-changed', { emojiDirectSend: emojiDirectSendCheckbox.checked });
      };
    }

    // Slow mode settings
    const slowModeEnabledCheckbox = $('slowModeEnabled');
    const slowModeSlider = $('slowModeSlider');
    const slowModeValueEl = $('slowModeValue');
    const slowModeSecondsGroup = $('slowModeSecondsGroup');

    function updateSlowModeVisibility() {
      if (slowModeSecondsGroup) {
        slowModeSecondsGroup.style.display = slowModeEnabledCheckbox && slowModeEnabledCheckbox.checked ? 'block' : 'none';
      }
    }

    if (slowModeEnabledCheckbox) {
      slowModeEnabledCheckbox.onchange = () => {
        updateSlowModeVisibility();
        ipcRenderer.send('settings-changed', { slowModeEnabled: slowModeEnabledCheckbox.checked });
      };
    }

    if (slowModeSlider) {
      slowModeSlider.oninput = () => {
        const val = parseInt(slowModeSlider.value, 10) || 3;
        if (slowModeValueEl) slowModeValueEl.textContent = val;
        ipcRenderer.send('settings-changed', { slowModeSeconds: val });
      };
    }

    // Remote Control settings
    const enableRemoteControlCheckbox = $('enableRemoteControl');
    if (enableRemoteControlCheckbox) {
      enableRemoteControlCheckbox.onchange = () => {
        if (enableRemoteControlCheckbox.checked) {
          ipcRenderer.send('enable-remote-control');
        } else {
          ipcRenderer.send('disable-remote-control');
        }
      };
    }

    // @Cee Agent settings
    const enableCeeAgentCheckbox = $('enableCeeAgent');
    const ceeApiKeyGroup = $('ceeApiKeyGroup');
    const ceeApiKeyStatus = $('ceeApiKeyStatus');
    const ceeApiProviderSelect = $('ceeApiProvider');
    const ceeApiKeyLabel = $('ceeApiKeyLabel');

    function updateCeeApiKeyVisibility() {
      if (ceeApiKeyGroup) {
        ceeApiKeyGroup.style.display = enableCeeAgentCheckbox && enableCeeAgentCheckbox.checked ? 'block' : 'none';
      }
    }

    function updateCeeApiKeyStatus(isSet) {
      if (ceeApiKeyStatus) {
        if (isSet) {
          ceeApiKeyStatus.textContent = 'API Key Set ‚úì';
          ceeApiKeyStatus.style.color = 'var(--accent)';
        } else {
          ceeApiKeyStatus.textContent = 'Not Set';
          ceeApiKeyStatus.style.color = 'var(--danger)';
        }
      }
    }

    function updateCeeApiProviderUI(provider) {
      const p = provider || 'openai';
      if (ceeApiKeyLabel) {
        ceeApiKeyLabel.textContent = p === 'gemini' ? 'Gemini API Key' : 'OpenAI API Key';
      }
      if (ceeApiKeyInput) {
        ceeApiKeyInput.placeholder = p === 'gemini' ? 'AIza...' : 'sk-...';
      }
      if (ceeApiProviderSelect) {
        ceeApiProviderSelect.value = p;
      }
    }

    // Provider dropdown handler
    if (ceeApiProviderSelect) {
      ceeApiProviderSelect.onchange = () => {
        const provider = ceeApiProviderSelect.value;
        updateCeeApiProviderUI(provider);
        // Clear the API key when switching providers
        if (ceeApiKeyInput) {
          ceeApiKeyInput.value = '';
          updateCeeApiKeyStatus(false);
        }
        ipcRenderer.send('settings-changed', { ceeApiProvider: provider, ceeApiKey: '' });
      };
    }

    // Persistent screen capture stream (for @Cee - avoids repeated permission dialogs)
    let screenStream = null;
    let screenVideo = null;
    let screenCanvas = null;

    async function initScreenCapture() {
      if (screenStream) {
        console.log('[Cee] Screen capture already initialized');
        return true;
      }

      try {
        // Get screen sources
        const sources = await ipcRenderer.invoke('get-screen-sources');
        if (!sources || sources.length === 0) {
          console.error('[Cee] No screen sources available');
          return false;
        }

        const sourceId = sources[0].id;
        console.log('[Cee] Requesting screen capture for source:', sourceId);

        // Request persistent stream - this shows permission dialog ONCE
        screenStream = await navigator.mediaDevices.getUserMedia({
          audio: false,
          video: {
            mandatory: {
              chromeMediaSource: 'desktop',
              chromeMediaSourceId: sourceId,
              maxWidth: 1920,
              maxHeight: 1080
            }
          }
        });

        // Create hidden video element to capture frames
        screenVideo = document.createElement('video');
        screenVideo.srcObject = screenStream;
        screenVideo.style.display = 'none';
        document.body.appendChild(screenVideo);
        await screenVideo.play();

        // Create canvas for frame capture
        screenCanvas = document.createElement('canvas');

        console.log('[Cee] Screen capture initialized successfully');
        return true;
      } catch (err) {
        console.error('[Cee] Failed to initialize screen capture:', err.message);
        return false;
      }
    }

    function stopScreenCapture() {
      if (screenStream) {
        screenStream.getTracks().forEach(track => track.stop());
        screenStream = null;
      }
      if (screenVideo) {
        screenVideo.remove();
        screenVideo = null;
      }
      screenCanvas = null;
      console.log('[Cee] Screen capture stopped');
    }

    async function captureScreenFrame() {
      if (!screenStream || !screenVideo || !screenCanvas) {
        console.log('[Cee] Screen capture not initialized, initializing...');
        const ok = await initScreenCapture();
        if (!ok) return null;
      }

      try {
        // Capture frame from video
        const width = screenVideo.videoWidth;
        const height = screenVideo.videoHeight;

        // Resize to max 512px width
        let targetWidth = width;
        let targetHeight = height;
        if (width > 512) {
          const scale = 512 / width;
          targetWidth = Math.round(width * scale);
          targetHeight = Math.round(height * scale);
        }

        screenCanvas.width = targetWidth;
        screenCanvas.height = targetHeight;
        const ctx = screenCanvas.getContext('2d');
        ctx.drawImage(screenVideo, 0, 0, targetWidth, targetHeight);

        // Convert to base64 JPEG
        const dataUrl = screenCanvas.toDataURL('image/jpeg', 0.8);
        const base64 = dataUrl.replace(/^data:image\/jpeg;base64,/, '');
        return base64;
      } catch (err) {
        console.error('[Cee] Failed to capture frame:', err.message);
        return null;
      }
    }

    // Handle screenshot request from main process
    ipcRenderer.on('capture-screenshot', async (event) => {
      const screenshot = await captureScreenFrame();
      ipcRenderer.send('screenshot-result', screenshot);
    });

    if (enableCeeAgentCheckbox) {
      enableCeeAgentCheckbox.onchange = async () => {
        updateCeeApiKeyVisibility();

        // Initialize or stop screen capture based on toggle
        if (enableCeeAgentCheckbox.checked) {
          const ok = await initScreenCapture();
          if (!ok) {
            // If screen capture fails, still allow enabling (will try again on first use)
            console.log('[Cee] Screen capture init failed, will retry on first use');
          }
        } else {
          stopScreenCapture();
        }

        ipcRenderer.send('settings-changed', { enableCeeAgent: enableCeeAgentCheckbox.checked });
      };
    }

    // API key input handling
    const ceeApiKeyInput = $('cee-api-key');
    const ceeApiKeyToggle = $('cee-api-key-toggle');
    const ceeApiKeyCopy = $('cee-api-key-copy');
    let ceeApiKeyVisible = false;

    function setCeeApiKeyVisible(visible) {
      ceeApiKeyVisible = !!visible;
      if (!ceeApiKeyInput || !ceeApiKeyToggle) return;
      ceeApiKeyInput.type = ceeApiKeyVisible ? 'text' : 'password';
      ceeApiKeyToggle.textContent = ceeApiKeyVisible ? 'Hide' : 'Show';
      ceeApiKeyToggle.setAttribute('aria-label', ceeApiKeyVisible ? 'Hide API key' : 'Show API key');
      if (ceeApiKeyCopy) ceeApiKeyCopy.classList.toggle('show', ceeApiKeyVisible && ceeApiKeyInput.value.length > 0);
    }

    if (ceeApiKeyToggle) {
      ceeApiKeyToggle.onclick = () => setCeeApiKeyVisible(!ceeApiKeyVisible);
    }

    // Save API key when input changes (debounced)
    let ceeApiKeySaveTimeout = null;
    if (ceeApiKeyInput) {
      ceeApiKeyInput.oninput = () => {
        // Update copy button visibility
        if (ceeApiKeyCopy) ceeApiKeyCopy.classList.toggle('show', ceeApiKeyVisible && ceeApiKeyInput.value.length > 0);

        // Debounce save (500ms after typing stops)
        if (ceeApiKeySaveTimeout) clearTimeout(ceeApiKeySaveTimeout);
        ceeApiKeySaveTimeout = setTimeout(() => {
          const key = ceeApiKeyInput.value.trim();
          ipcRenderer.send('settings-changed', { ceeApiKey: key });
          // Update status immediately based on input
          updateCeeApiKeyStatus(key.length > 0);
        }, 500);
      };

      // Also save on blur (in case user tabs away quickly)
      ceeApiKeyInput.onblur = () => {
        if (ceeApiKeySaveTimeout) {
          clearTimeout(ceeApiKeySaveTimeout);
          ceeApiKeySaveTimeout = null;
        }
        const key = ceeApiKeyInput.value.trim();
        ipcRenderer.send('settings-changed', { ceeApiKey: key });
        updateCeeApiKeyStatus(key.length > 0);
      };
    }

    async function copyCeeApiKey() {
      if (!ceeApiKeyVisible || !ceeApiKeyInput) return;
      const text = String(ceeApiKeyInput.value || '');
      if (!text) return;

      let ok = false;
      try {
        if (clipboard && clipboard.writeText) {
          clipboard.writeText(text);
          ok = true;
        }
      } catch (_) { }

      if (!ok) {
        try {
          if (navigator.clipboard && navigator.clipboard.writeText) {
            await navigator.clipboard.writeText(text);
            ok = true;
          }
        } catch (_) { }
      }

      if (ceeApiKeyCopy) {
        const prev = ceeApiKeyCopy.textContent;
        ceeApiKeyCopy.textContent = ok ? '‚úì' : '!';
        setTimeout(() => {
          if (ceeApiKeyCopy) ceeApiKeyCopy.textContent = prev || 'üìã';
        }, 700);
      }
    }

    if (ceeApiKeyCopy) {
      ceeApiKeyCopy.onclick = copyCeeApiKey;
    }

    // Explicitly handle focus for API key input (Electron quirk workaround)
    if (ceeApiKeyInput) {
      // Handle mousedown to focus before click event
      ceeApiKeyInput.addEventListener('mousedown', (e) => {
        e.stopPropagation();
        // Request window focus from main process
        ipcRenderer.send('request-focus');
        // Small delay to ensure focus sticks
        setTimeout(() => ceeApiKeyInput.focus(), 10);
      });

      // Prevent focus loss when clicking inside the input
      ceeApiKeyInput.addEventListener('click', (e) => {
        e.stopPropagation();
        ceeApiKeyInput.focus();
      });

      // When input gets focus, ensure window is focused
      ceeApiKeyInput.addEventListener('focus', () => {
        ipcRenderer.send('request-focus');
      });

      // Prevent keyboard events from propagating to parent/document
      ceeApiKeyInput.addEventListener('keydown', (e) => {
        e.stopPropagation();
      });

      ceeApiKeyInput.addEventListener('keyup', (e) => {
        e.stopPropagation();
      });

      ceeApiKeyInput.addEventListener('keypress', (e) => {
        e.stopPropagation();
      });
    }
    setCeeApiKeyVisible(false);

    // Custom system prompt handling (debounced)
    const ceeSystemPromptInput = $('ceeSystemPrompt');
    let ceeSystemPromptSaveTimeout = null;
    if (ceeSystemPromptInput) {
      ceeSystemPromptInput.oninput = () => {
        if (ceeSystemPromptSaveTimeout) clearTimeout(ceeSystemPromptSaveTimeout);
        ceeSystemPromptSaveTimeout = setTimeout(() => {
          const prompt = ceeSystemPromptInput.value.trim();
          ipcRenderer.send('settings-changed', { ceeSystemPrompt: prompt });
        }, 500);
      };
      ceeSystemPromptInput.onblur = () => {
        if (ceeSystemPromptSaveTimeout) {
          clearTimeout(ceeSystemPromptSaveTimeout);
          ceeSystemPromptSaveTimeout = null;
        }
        const prompt = ceeSystemPromptInput.value.trim();
        ipcRenderer.send('settings-changed', { ceeSystemPrompt: prompt });
      };
    }

    // Trim excess messages
    function trimMessages() {
      while (messages.children.length > maxMessages) {
        messages.firstChild.remove();
      }
    }

    // Update opacity with gentle decay (stays visible longer, gradual fade)
    function updateOpacity() {
      const msgs = messages.querySelectorAll('.msg');
      const count = msgs.length;
      msgs.forEach((msg, i) => {
        const age = count - 1 - i; // 0 = newest, higher = older
        const normalizedAge = age / Math.max(1, maxMessages - 1); // 0 to 1
        // Gentle ease-out curve using cosine for smooth natural fade
        const opacity = Math.cos(Math.pow(normalizedAge, 1.3) * Math.PI / 2);
        msg.style.opacity = Math.max(0.1, opacity);
      });
    }

    // Auto-hide timeout (in ms)
    const MSG_DISPLAY_TIME = 5000;

    // Generate consistent color for username
    function getUserColor(username) {
      // Hash the username to get a consistent number
      let hash = 0;
      for (let i = 0; i < username.length; i++) {
        hash = username.charCodeAt(i) + ((hash << 5) - hash);
        hash = hash & hash; // Convert to 32bit integer
      }

      // Use hash to generate HSL color
      const hue = Math.abs(hash) % 360;
      const saturation = 65 + (Math.abs(hash >> 8) % 20); // 65-85%
      const lightness = 65 + (Math.abs(hash >> 16) % 15);  // 65-80%

      return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
    }

    // Message ID counter (for local messages without server ID)
    let localMsgId = 0;

    // Message helpers
    function addMsg(user, text, msgId = null) {
      const id = msgId || (--localMsgId); // Use negative IDs for local messages

      const el = document.createElement('div');
      el.className = 'msg';
      el.dataset.msgId = id;
      el.innerHTML = `<button class="del">üóë</button><span class="user">${user}:</span><span class="text">${text}</span>`;

      // Apply username color
      const userEl = el.querySelector('.user');
      userEl.style.color = getUserColor(user);

      // Apply custom font size if set
      if (messages.dataset.fontSize) {
        const size = parseInt(messages.dataset.fontSize);
        el.style.fontSize = size + 'px';
        userEl.style.fontSize = (size - 2) + 'px';
      }

      // Delete button handler
      el.querySelector('.del').onclick = () => {
        deleteMessage(el);
      };

      // Auto-hide after display time
      setTimeout(() => {
        if (el.parentNode) {
          deleteMessage(el);
        }
      }, MSG_DISPLAY_TIME);

      messages.appendChild(el);
      trimMessages();
      messages.scrollTop = messages.scrollHeight;
      updateOpacity();
      updateJoinTextVisibility();

      return id;
    }

    // Delete message with animation
    function deleteMessage(el) {
      el.style.transition = 'opacity 1.3s';
      el.style.opacity = '0';
      setTimeout(() => { el.remove(); updateOpacity(); updateJoinTextVisibility(); }, 1300);
    }

    // Delete message by ID (from admin)
    function deleteMessageById(id) {
      const el = messages.querySelector(`[data-msg-id="${id}"]`);
      if (el) deleteMessage(el);
    }

    // Listen for messages from WebSocket server (via main process)
    ipcRenderer.on('new-message', (_, data) => {
      addMsg(data.user, data.text, data.id);
    });

    // Listen for message deletion from admin
    ipcRenderer.on('delete-message', (_, data) => {
      deleteMessageById(data.id);
    });

    // Listen for settings updates from admin
    ipcRenderer.on('settings-update', (_, settings) => {
      if (settings.hideIp !== undefined) {
        const hideIpCheckbox = $('hideIp');
        if (hideIpCheckbox) hideIpCheckbox.checked = settings.hideIp;
        // Refresh session info to get updated URLs
        initSession().then(() => {
          // Update QR code if it's currently displayed
          if (showMobileLinkCheckbox && showMobileLinkCheckbox.checked) {
            updateQRDisplay(true);
          }
        });
      }
      if (settings.maxMessages !== undefined) {
        maxMessages = settings.maxMessages;
        maxMsgSlider.value = maxMessages;
        maxMsgValue.textContent = maxMessages;
        trimMessages();
        updateOpacity();
      }
      if (settings.fontSize !== undefined) {
        fontSizeSlider.value = settings.fontSize;
        fontSizeValue.textContent = settings.fontSize;
        applyFontSize(settings.fontSize);
      }
      if (settings.showJoinCode !== undefined) {
        showJoinCode = settings.showJoinCode;
        showJoinCodeCheckbox.checked = showJoinCode;
        updateJoinTextVisibility();
      }
      if (settings.showMobileLink !== undefined) {
        showMobileLinkCheckbox.checked = settings.showMobileLink;
        updateQRDisplay(settings.showMobileLink);
      }
      if (settings.disableChatHistory !== undefined) {
        disableChatHistoryCheckbox.checked = settings.disableChatHistory;
      }
      if (settings.enableFeedbackForm !== undefined && enableFeedbackFormCheckbox) {
        enableFeedbackFormCheckbox.checked = settings.enableFeedbackForm;
      }
      if (settings.emojiDirectSend !== undefined && emojiDirectSendCheckbox) {
        emojiDirectSendCheckbox.checked = settings.emojiDirectSend;
      }
      if (settings.slowModeEnabled !== undefined && slowModeEnabledCheckbox) {
        slowModeEnabledCheckbox.checked = settings.slowModeEnabled;
        updateSlowModeVisibility();
      }
      if (settings.slowModeSeconds !== undefined) {
        const secs = parseInt(settings.slowModeSeconds, 10) || 3;
        if (slowModeSlider) slowModeSlider.value = secs;
        if (slowModeValueEl) slowModeValueEl.textContent = secs;
      }
      // Remote Control settings
      if (settings.remoteEnabled !== undefined && enableRemoteControlCheckbox) {
        enableRemoteControlCheckbox.checked = settings.remoteEnabled;
      }
      // @Cee Agent settings
      if (settings.enableCeeAgent !== undefined && enableCeeAgentCheckbox) {
        enableCeeAgentCheckbox.checked = settings.enableCeeAgent;
        updateCeeApiKeyVisibility();
      }
      if (settings.ceeApiProvider !== undefined) {
        updateCeeApiProviderUI(settings.ceeApiProvider);
      }
      if (settings.ceeApiKeySet !== undefined) {
        updateCeeApiKeyStatus(settings.ceeApiKeySet);
        // Update copy button visibility based on whether key is set
        if (ceeApiKeyCopy && ceeApiKeyInput) {
          ceeApiKeyCopy.classList.toggle('show', ceeApiKeyVisible && settings.ceeApiKeySet);
        }
      }
      if (settings.ceeSystemPrompt !== undefined && ceeSystemPromptInput) {
        ceeSystemPromptInput.value = settings.ceeSystemPrompt;
      }
    });

    // Get session info on startup
    function normalizeExternalUrl(url) {
      const u = String(url || '').trim();
      if (!u) return '';
      // If protocol missing, default to http (shouldn't happen, but keeps links usable).
      if (!/^https?:\/\//i.test(u)) return `http://${u}`;
      return u;
    }

    function setExternalLink(el, url) {
      if (!el) return;
      const safeUrl = normalizeExternalUrl(url);
      el.textContent = url || '';
      el.href = safeUrl || '#';
      el.onclick = (e) => {
        e.preventDefault();
        if (safeUrl) shell.openExternal(safeUrl);
      };
    }

    async function initSession() {
      try {
        const info = await ipcRenderer.invoke('get-session-info');
        $('session-code').textContent = info.code;
        const pw = $('admin-password');
        if (pw) pw.value = info.adminPassword || '';
        setExternalLink($('mobile-url'), info.mobileUrl);
        setExternalLink($('admin-url'), info.adminUrl);
        mobileUrl = info.mobileUrl;
      } catch (e) {
        console.log('Could not get session info');
      }
    }
    initSession();

    // Admin password show/hide + selectable when visible
    const adminPasswordInput = $('admin-password');
    const adminPasswordToggle = $('admin-password-toggle');
    const adminPasswordCopy = $('admin-password-copy');
    let adminPasswordVisible = false;

    function setAdminPasswordVisible(visible) {
      adminPasswordVisible = !!visible;
      if (!adminPasswordInput || !adminPasswordToggle) return;
      adminPasswordInput.type = adminPasswordVisible ? 'text' : 'password';
      adminPasswordInput.classList.toggle('visible', adminPasswordVisible);
      adminPasswordToggle.textContent = adminPasswordVisible ? 'Hide' : 'Show';
      adminPasswordToggle.setAttribute('aria-label', adminPasswordVisible ? 'Hide admin password' : 'Show admin password');
      if (adminPasswordCopy) adminPasswordCopy.classList.toggle('show', adminPasswordVisible);

      // Only allow selection/copy when visible
      if (adminPasswordVisible) {
        // Select all for quick copy
        try {
          adminPasswordInput.focus({ preventScroll: true });
          adminPasswordInput.setSelectionRange(0, adminPasswordInput.value.length);
        } catch (_) { }
      } else {
        try {
          adminPasswordInput.setSelectionRange(0, 0);
          adminPasswordInput.blur();
        } catch (_) { }
      }
    }

    if (adminPasswordToggle) {
      adminPasswordToggle.onclick = () => setAdminPasswordVisible(!adminPasswordVisible);
    }

    async function copyAdminPassword() {
      if (!adminPasswordVisible || !adminPasswordInput) return;
      const text = String(adminPasswordInput.value || '');
      if (!text) return;

      let ok = false;
      try {
        if (clipboard && clipboard.writeText) {
          clipboard.writeText(text);
          ok = true;
        }
      } catch (_) { }

      // Fallback (in case clipboard module is unavailable)
      if (!ok) {
        try {
          if (navigator.clipboard && navigator.clipboard.writeText) {
            await navigator.clipboard.writeText(text);
            ok = true;
          }
        } catch (_) { }
      }

      if (adminPasswordCopy) {
        // Briefly swap the icon to confirm.
        const prev = adminPasswordCopy.textContent;
        adminPasswordCopy.textContent = ok ? '‚úì' : '!';
        setTimeout(() => {
          if (adminPasswordCopy) adminPasswordCopy.textContent = prev || 'üìã';
        }, 700);
      }
    }

    if (adminPasswordCopy) {
      adminPasswordCopy.onclick = copyAdminPassword;
    }
    setAdminPasswordVisible(false);

    // Listen for open-settings command (on startup)
    ipcRenderer.on('open-settings', () => {
      openSettings();
    });

    // Show mode on start
    setTimeout(() => { mode.classList.add('show'); setTimeout(() => mode.classList.remove('show'), 2000); }, 500);
  </script>
</body>

</html>