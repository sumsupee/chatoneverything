<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, interactive-widget=resizes-content">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <title>Chat on Everything Controller</title>
  <link rel="icon" href="/assets/title_plain.png" type="image/png">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&family=Outfit:wght@400;500;600&display=swap" rel="stylesheet">
  <style>
    :root {
      /* Theatre dark theme */
      --bg: #000;
      --bg-solid: #000;
      --accent: #8a8a8a;
      --accent2: #6f6f6f;
      --text: #e8e8e8;
      --text-dim: #9a9a9a;
      --border: rgba(255, 255, 255, 0.10);
      --border-strong: rgba(255, 255, 255, 0.18);
      --danger: #b24b57;
    }

    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    html {
      margin: 0;
      padding: 0;
      height: 100%;
      height: 100dvh; /* Dynamic viewport height for mobile */
      background: var(--bg-solid);
      font-family: 'Outfit', sans-serif;
      color: var(--text);
      overflow: hidden;
    }
    
    body {
      margin: 0;
      padding: 0;
      height: 100%;
      height: 100dvh;
      background: var(--bg-solid);
      font-family: 'Outfit', sans-serif;
      color: var(--text);
      overflow: hidden;
      position: fixed;
      width: 100%;
      top: 0;
      left: 0;
    }

    #app {
      display: flex;
      flex-direction: column;
      height: 100%;
      height: 100dvh;
      max-width: 500px;
      margin: 0 auto;
      overflow: hidden;
    }

    /* Header */
    header {
      padding: 20px;
      text-align: center;
      background: rgba(255, 255, 255, 0.02);
      border-bottom: 1px solid var(--border);
    }

    header h1 {
      margin: 0;
      font: 600 20px 'JetBrains Mono', monospace;
      color: #a8a8a8;
    }

    header p {
      margin: 8px 0 0 0;
      font-size: 13px;
      color: var(--text-dim);
    }

    /* Status indicator */
    .status {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      margin-top: 10px;
      font: 12px 'JetBrains Mono', monospace;
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--danger);
      transition: background 0.3s;
    }

    .status-dot.connected {
      background: rgba(255, 255, 255, 0.55);
      box-shadow: none;
    }

    /* Connection panel */
    #connect-panel {
      padding: 24px 20px;
      flex: 1;
      display: flex;
      flex-direction: column;
      justify-content: center;
    }

    #connect-panel.hidden {
      display: none;
    }

    .form-group {
      margin-bottom: 20px;
    }

    label {
      display: block;
      font: 500 11px 'JetBrains Mono', monospace;
      color: var(--text-dim);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 8px;
    }

    input[type="text"] {
      width: 100%;
      padding: 14px 16px;
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid var(--border-strong);
      border-radius: 10px;
      color: var(--text);
      font: 16px 'Outfit', sans-serif;
      outline: none;
      transition: border-color 0.2s, background 0.2s;
    }

    input[type="text"]:focus {
      border-color: rgba(255, 255, 255, 0.28);
      background: rgba(255, 255, 255, 0.04);
    }

    input[type="text"]::placeholder {
      color: var(--text-dim);
    }

    .btn {
      width: 100%;
      padding: 16px;
      border: 1px solid var(--border-strong);
      border-radius: 10px;
      font: 600 16px 'Outfit', sans-serif;
      cursor: pointer;
      transition: transform 0.1s, opacity 0.2s;
      background: transparent;
      color: var(--text);
    }

    .btn:active {
      transform: scale(0.98);
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .btn-primary {
      background: transparent;
      color: var(--text);
    }

    .btn-secondary {
      background: transparent;
      color: var(--text);
    }

    /* Chat panel */
    #chat-panel {
      flex: 1;
      display: none;
      flex-direction: column;
      overflow: hidden;
      min-height: 0;
      position: relative;
    }

    #chat-panel.visible {
      display: flex;
    }

    /* Messages area */
    #messages {
      flex: 1;
      overflow-y: auto;
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      min-height: 0;
    }

    .msg {
      background: transparent;
      padding: 10px 14px;
      border-radius: 10px;
      border: 1px solid var(--border);
      position: relative;
      animation: slideUp 0.3s ease;
    }

    .msg::before {
      content: none;
    }

    .msg .user {
      font: 600 11px 'JetBrains Mono', monospace;
      color: var(--text-dim);
      margin-right: 8px;
    }

    .msg .text {
      font-size: 14px;
      color: var(--text);
    }

    .msg.own {
      background: transparent;
      border-color: var(--border);
    }

    .empty-state {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-dim);
      font-size: 14px;
      text-align: center;
      padding: 20px;
    }


    /* Message input */
    #input-area {
      padding: 16px;
      background: rgba(0, 0, 0, 0.85);
      border-top: 1px solid var(--border);
    }

    .input-row {
      display: flex;
      gap: 10px;
    }

    #msg-input {
      flex: 1;
      padding: 14px 16px;
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid var(--border-strong);
      border-radius: 24px;
      color: var(--text);
      font: 16px 'Outfit', sans-serif;
      outline: none;
    }

    #msg-input:focus {
      border-color: rgba(255, 255, 255, 0.28);
    }

    #send-btn {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: transparent;
      border: 1px solid var(--border-strong);
      color: rgba(255, 255, 255, 0.75);
      font-size: 20px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: transform 0.1s;
    }

    #send-btn:active {
      transform: scale(0.9);
    }

    #send-btn:disabled {
      opacity: 0.5;
    }

    /* Error message */
    .error {
      color: var(--danger);
      font-size: 13px;
      margin-top: 10px;
      text-align: center;
    }

    @keyframes slideUp {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    /* Emoji shortcuts */
    #emoji-bar {
      display: flex;
      gap: 8px;
      padding: 0 0 10px 0;
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
    }
    #emoji-bar::-webkit-scrollbar { height: 0; }
    .emoji-btn {
      border: 1px solid rgba(255, 255, 255, 0.14);
      background: transparent;
      color: var(--text);
      border-radius: 12px;
      padding: 10px 12px;
      font-size: 18px;
      line-height: 1;
      cursor: pointer;
      flex: 0 0 auto;
    }
    .emoji-btn:active { transform: scale(0.95); }

    /* Safe area for notched phones */
    @supports (padding-top: env(safe-area-inset-top)) {
      header {
        padding-top: calc(20px + env(safe-area-inset-top));
      }
      #input-area {
        padding-bottom: calc(16px + env(safe-area-inset-bottom));
      }
    }

    /* Feedback overlay */
    #feedback-overlay {
      position: absolute;
      inset: 0;
      display: none;
      background: rgba(0, 0, 0, 0.65);
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
      align-items: center;
      justify-content: center;
      padding: 18px;
      z-index: 50;
    }
    #feedback-overlay.visible { display: flex; }

    .feedback-card {
      width: 100%;
      max-width: 440px;
      background: rgba(0, 0, 0, 0.92);
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 14px;
      padding: 16px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.45);
    }
    .feedback-title {
      font: 600 14px 'JetBrains Mono', monospace;
      color: #a8a8a8;
      margin-bottom: 12px;
      text-transform: uppercase;
      letter-spacing: 0.6px;
    }
    .stars {
      display: flex;
      gap: 8px;
      margin-bottom: 12px;
    }
    .star-btn {
      width: 44px;
      height: 44px;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      background: transparent;
      color: rgba(255, 255, 255, 0.55);
      font-size: 22px;
      line-height: 1;
      cursor: pointer;
    }
    .star-btn.filled {
      color: rgba(255, 255, 255, 0.80);
      border-color: rgba(255, 255, 255, 0.28);
      background: rgba(255, 255, 255, 0.04);
    }
    #feedback-text {
      width: 100%;
      resize: none;
      min-height: 110px;
      padding: 12px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      background: rgba(255, 255, 255, 0.03);
      color: var(--text);
      font: 14px 'Outfit', sans-serif;
      outline: none;
    }
    #feedback-text:focus {
      border-color: rgba(255, 255, 255, 0.28);
    }
    .feedback-meta {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-top: 10px;
      gap: 10px;
      font: 12px 'JetBrains Mono', monospace;
      color: var(--text-dim);
    }
    #feedback-error {
      color: var(--danger);
      text-align: right;
      flex: 1;
      min-width: 0;
      word-break: break-word;
    }
    #feedback-submit {
      margin-top: 12px;
    }
  </style>
</head>
<body>
  <div id="app">
    <header>
      <h1>Chat on Everything</h1>
      <p>Send messages to the screen</p>
      <div class="status">
        <span class="status-dot" id="status-dot"></span>
        <span id="status-text">Disconnected</span>
      </div>
    </header>

    <!-- Connection Panel -->
    <div id="connect-panel">
      <div class="form-group">
        <label>Server Address</label>
        <input type="text" id="server-input" placeholder="192.168.1.100:8765" autocomplete="off" autocapitalize="off">
      </div>
      <div class="form-group">
        <label>Your Name</label>
        <input type="text" id="name-input" placeholder="Enter your display name" autocomplete="off">
      </div>
      <div class="error" id="connect-error"></div>
      <button class="btn btn-primary" id="connect-btn">Connect</button>
    </div>

    <!-- Chat Panel -->
    <div id="chat-panel">
      <div id="messages">
        <div class="empty-state">
          Send your first message! This will be visible to everyone. 
        </div>
      </div>
      <div id="input-area">
        <div id="emoji-bar" aria-label="Reactions">
          <button class="emoji-btn" type="button" data-emoji="üòÇ" aria-label="Laugh">üòÇ</button>
          <button class="emoji-btn" type="button" data-emoji="‚ù§Ô∏è" aria-label="Love">‚ù§Ô∏è</button>
          <button class="emoji-btn" type="button" data-emoji="üëç" aria-label="Thumbs up">üëç</button>
          <button class="emoji-btn" type="button" data-emoji="üëé" aria-label="Boo">üëé</button>
          <button class="emoji-btn" type="button" data-emoji="üòÆ" aria-label="Wow">üòÆ</button>
          <button class="emoji-btn" type="button" data-emoji="üò¢" aria-label="Cry">üò¢</button>
          <button class="emoji-btn" type="button" id="custom-emoji-btn" data-emoji="‚≠ê" aria-label="Custom reaction">‚≠ê</button>
        </div>
        <div class="input-row">
          <input type="text" id="msg-input" placeholder="Type a message..." autocomplete="off">
          <button id="send-btn">‚û§</button>
        </div>
      </div>

      <!-- Feedback overlay (shown when enabled by admin) -->
      <div id="feedback-overlay" aria-hidden="true">
        <div class="feedback-card" role="dialog" aria-modal="true" aria-label="Feedback form">
          <div class="feedback-title">Rate the event</div>
          <div class="stars" id="feedback-stars" role="radiogroup" aria-label="Rate the event (1 to 5 stars)">
            <button class="star-btn" type="button" data-value="1" aria-label="1 star">‚òÖ</button>
            <button class="star-btn" type="button" data-value="2" aria-label="2 stars">‚òÖ</button>
            <button class="star-btn" type="button" data-value="3" aria-label="3 stars">‚òÖ</button>
            <button class="star-btn" type="button" data-value="4" aria-label="4 stars">‚òÖ</button>
            <button class="star-btn" type="button" data-value="5" aria-label="5 stars">‚òÖ</button>
          </div>
          <textarea id="feedback-text" placeholder="Optional: tell us anything (max 150 words)"></textarea>
          <div class="feedback-meta">
            <div id="feedback-word-count">0/150 words</div>
            <div id="feedback-error"></div>
          </div>
          <button class="btn btn-primary" id="feedback-submit" type="button">Submit</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    const $ = id => document.getElementById(id);

    // Elements
    const connectPanel = $('connect-panel');
    const chatPanel = $('chat-panel');
    const serverInput = $('server-input');
    const nameInput = $('name-input');
    const connectBtn = $('connect-btn');
    const connectError = $('connect-error');
    const statusDot = $('status-dot');
    const statusText = $('status-text');
    const messagesContainer = $('messages');
    const msgInput = $('msg-input');
    const sendBtn = $('send-btn');
    const emojiBar = $('emoji-bar');
    const customEmojiBtn = $('custom-emoji-btn');
    const feedbackOverlay = $('feedback-overlay');
    const feedbackStars = $('feedback-stars');
    const feedbackText = $('feedback-text');
    const feedbackSubmit = $('feedback-submit');
    const feedbackError = $('feedback-error');
    const feedbackWordCount = $('feedback-word-count');

    let ws = null;
    let username = '';
    let sessionCode = '';
    let disableChatHistory = true; // Default: only show own messages
    let customEmoji = '‚≠ê';
    let emojiDirectSend = true; // When true, emoji buttons send directly; when false, insert into text box
    let slowModeEnabled = false;
    let slowModeSeconds = 3;
    const MAX_WORDS_PER_MESSAGE = 50;
    
    // Reconnection state
    let reconnectAttempts = 0;
    let reconnectTimer = null;
    let heartbeatTimer = null;
    let lastServerAddress = '';
    const MAX_RECONNECT_ATTEMPTS = 50;
    const RECONNECT_DELAY_BASE = 1000; // Start with 1 second
    const HEARTBEAT_INTERVAL = 25000; // 25 seconds (most servers timeout at 30s)
    const MAX_WORDS_FEEDBACK = 150;

    let enableFeedbackForm = false;
    let feedbackCycleId = 0;
    let selectedRating = 0;
    
    // Detect if page is served over HTTPS (secure tunnel)
    const isSecure = window.location.protocol === 'https:';

    // Load saved values
    serverInput.value = localStorage.getItem('livechat_server') || '';
    nameInput.value = localStorage.getItem('livechat_name') || '';

    // Auto-detect server from URL if accessed from same network
    if (!serverInput.value && window.location.hostname !== 'localhost') {
      if (isSecure) {
        // For HTTPS tunnel, leave empty - user needs to enter WSS tunnel URL
        // (HTTP and WS tunnels have different URLs with localtunnel)
        serverInput.placeholder = 'Enter WSS tunnel URL';
      } else {
        serverInput.value = window.location.hostname + ':8765';
      }
    }

    function setStatus(connected, text) {
      statusDot.classList.toggle('connected', connected);
      statusText.textContent = text;
    }

    function showError(msg) {
      connectError.textContent = msg;
    }

    function clearError() {
      connectError.textContent = '';
    }

    function connect() {
      const server = serverInput.value.trim();
      const name = nameInput.value.trim();

      if (!server) {
        showError('Please enter server address');
        return;
      }
      if (!name) {
        showError('Please enter your name');
        return;
      }

      clearError();
      connectBtn.disabled = true;
      connectBtn.textContent = 'Connecting...';
      setStatus(false, 'Connecting...');

      // Save values
      localStorage.setItem('livechat_server', server);
      localStorage.setItem('livechat_name', name);

      username = name;
      lastServerAddress = server;

      // Create WebSocket connection
      // Determine protocol: use wss:// for HTTPS pages or if explicitly specified
      let wsUrl;
      if (server.startsWith('ws://') || server.startsWith('wss://')) {
        wsUrl = server;
      } else if (isSecure || server.includes('.loca.lt') || server.includes('ngrok')) {
        // Use secure WebSocket for HTTPS pages or known tunnel services
        wsUrl = `wss://${server}`;
      } else {
        wsUrl = `ws://${server}`;
      }
      
      try {
        ws = new WebSocket(wsUrl);
      } catch (e) {
        showError('Invalid server address');
        connectBtn.disabled = false;
        connectBtn.textContent = 'Connect';
        setStatus(false, 'Disconnected');
        return;
      }

      ws.onopen = () => {
        setStatus(true, 'Connected');
        connectPanel.classList.add('hidden');
        chatPanel.classList.add('visible');
        reconnectAttempts = 0;
        startHeartbeat();
        updateFeedbackOverlay();
      };

      ws.onmessage = handleWebSocketMessage;

      ws.onerror = () => {
        showError('Connection failed. Check the server address.');
        connectBtn.disabled = false;
        connectBtn.textContent = 'Connect';
        setStatus(false, 'Connection failed');
      };

      ws.onclose = () => {
        clearHeartbeat();
        setStatus(false, 'Disconnected');
        if (chatPanel.classList.contains('visible')) {
          // Try to reconnect instead of fully disconnecting
          scheduleReconnect();
        }
        connectBtn.disabled = false;
        connectBtn.textContent = 'Connect';
      };
    }
    
    function handleWebSocketMessage(event) {
      try {
        const data = JSON.parse(event.data);
        
        if (data.type === 'session') {
          sessionCode = data.code;
          updateFeedbackOverlay();
        } else if (data.type === 'blocked') {
          // Server rejected messages from this IP.
          setStatus(false, 'Blocked');
          msgInput.disabled = true;
          sendBtn.disabled = true;
          // Show a notice in the chat panel.
          const emptyState = messagesContainer.querySelector('.empty-state');
          if (emptyState) emptyState.remove();
          const notice = document.createElement('div');
          notice.className = 'empty-state';
          notice.textContent = 'You have been blocked by the admin. You can no longer send messages from this network/IP.';
          messagesContainer.appendChild(notice);
        } else if (data.type === 'slow-mode') {
          showSlowModeNotice(data.remainingSeconds || 1);
        } else if (data.type === 'message') {
          if (data.id !== undefined && data.user && data.text) {
            const isOwn = data.user === username;
            // If chat history is disabled for others, only show own messages
            if (!disableChatHistory || isOwn) {
              addMessage(data.id, data.user, data.text, isOwn);
            }
          }
        } else if (data.type === 'message-deleted') {
          if (data.msgId !== undefined) {
            removeMessage(data.msgId);
          }
        } else if (data.type === 'settings-sync') {
          if (data.settings) {
            if (data.settings.disableChatHistory !== undefined) {
              disableChatHistory = data.settings.disableChatHistory;
            }
            if (data.settings.customEmoji !== undefined) {
              setCustomEmoji(data.settings.customEmoji);
            }
            if (data.settings.emojiDirectSend !== undefined) {
              emojiDirectSend = !!data.settings.emojiDirectSend;
            }
            if (data.settings.slowModeEnabled !== undefined) {
              slowModeEnabled = !!data.settings.slowModeEnabled;
            }
            if (data.settings.slowModeSeconds !== undefined) {
              slowModeSeconds = parseInt(data.settings.slowModeSeconds, 10) || 3;
            }
            if (data.settings.enableFeedbackForm !== undefined) {
              enableFeedbackForm = !!data.settings.enableFeedbackForm;
            }
            if (data.settings.feedbackCycleId !== undefined) {
              const prevCycle = feedbackCycleId;
              feedbackCycleId = parseInt(data.settings.feedbackCycleId, 10) || 0;
              if (feedbackCycleId !== prevCycle) {
                selectedRating = 0;
                setStarsUI(0);
                if (feedbackText) feedbackText.value = '';
                updateFeedbackWordCount();
              }
            }
            updateFeedbackOverlay();
          }
        }
        // Ignore other message types (including 'pong' responses)
      } catch (e) {
        console.error('Error handling message:', e);
      }
    }

    function disconnect(showUI = true) {
      clearHeartbeat();
      clearReconnectTimer();
      if (ws) {
        ws.close();
        ws = null;
      }
      if (showUI) {
        chatPanel.classList.remove('visible');
        connectPanel.classList.remove('hidden');
        setStatus(false, 'Disconnected');
        hideFeedbackOverlay();
        // Clear messages
        messagesContainer.innerHTML = '<div class="empty-state">Send your first message! This will be visible to everyone.</div>';
        // Reset reconnect state
        reconnectAttempts = 0;
      }
    }
    
    function clearReconnectTimer() {
      if (reconnectTimer) {
        clearTimeout(reconnectTimer);
        reconnectTimer = null;
      }
    }
    
    function clearHeartbeat() {
      if (heartbeatTimer) {
        clearInterval(heartbeatTimer);
        heartbeatTimer = null;
      }
    }
    
    function startHeartbeat() {
      clearHeartbeat();
      heartbeatTimer = setInterval(() => {
        if (ws && ws.readyState === WebSocket.OPEN) {
          try {
            // Send a ping message (server should ignore unknown types)
            ws.send(JSON.stringify({ type: 'ping' }));
          } catch (e) {
            // Connection might be dead
            scheduleReconnect();
          }
        }
      }, HEARTBEAT_INTERVAL);
    }
    
    function scheduleReconnect() {
      if (reconnectTimer) return; // Already scheduled
      if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
        setStatus(false, 'Connection lost');
        return;
      }
      
      // Exponential backoff with max of 10 seconds
      const delay = Math.min(RECONNECT_DELAY_BASE * Math.pow(1.5, reconnectAttempts), 10000);
      reconnectAttempts++;
      
      setStatus(false, `Reconnecting (${reconnectAttempts})...`);
      
      reconnectTimer = setTimeout(() => {
        reconnectTimer = null;
        if (lastServerAddress && username) {
          attemptReconnect();
        }
      }, delay);
    }
    
    function attemptReconnect() {
      if (ws && ws.readyState === WebSocket.OPEN) return; // Already connected
      
      const server = lastServerAddress;
      if (!server || !username) return;
      
      // Create WebSocket connection
      let wsUrl;
      if (server.startsWith('ws://') || server.startsWith('wss://')) {
        wsUrl = server;
      } else if (isSecure || server.includes('.loca.lt') || server.includes('ngrok')) {
        wsUrl = `wss://${server}`;
      } else {
        wsUrl = `ws://${server}`;
      }
      
      try {
        ws = new WebSocket(wsUrl);
      } catch (e) {
        scheduleReconnect();
        return;
      }
      
      ws.onopen = () => {
        setStatus(true, 'Connected');
        reconnectAttempts = 0;
        startHeartbeat();
        updateFeedbackOverlay();
      };
      
      ws.onmessage = handleWebSocketMessage;
      
      ws.onerror = () => {
        scheduleReconnect();
      };
      
      ws.onclose = () => {
        clearHeartbeat();
        if (chatPanel.classList.contains('visible')) {
          scheduleReconnect();
        }
      };
    }

    function normalizeWhitespace(s) {
      return String(s || '').replace(/\s+/g, ' ').trim();
    }

    function countWords(text) {
      const normalized = normalizeWhitespace(text);
      if (!normalized) return 0;
      return normalized.split(' ').filter(Boolean).length;
    }

    function truncateToMaxWords(text, maxWords) {
      const normalized = normalizeWhitespace(text);
      if (!normalized) return '';
      const words = normalized.split(' ').filter(Boolean);
      if (words.length <= maxWords) return normalized;
      return words.slice(0, maxWords).join(' ');
    }

    let slowModeNoticeTimeout = null;

    function showSlowModeNotice(seconds) {
      // Show a temporary notice in the center of the screen
      let notice = document.getElementById('slow-mode-notice');
      if (!notice) {
        notice = document.createElement('div');
        notice.id = 'slow-mode-notice';
        notice.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(176,138,70,0.98);color:#fff;padding:16px 28px;border-radius:14px;font:600 16px "Outfit",sans-serif;z-index:9999;box-shadow:0 6px 24px rgba(0,0,0,0.5);text-align:center;';
        document.body.appendChild(notice);
      }
      notice.textContent = `Slow mode: wait ${seconds}s`;
      notice.style.display = 'block';
      if (slowModeNoticeTimeout) clearTimeout(slowModeNoticeTimeout);
      slowModeNoticeTimeout = setTimeout(() => {
        notice.style.display = 'none';
      }, 2500);
    }

    function sendText(text, shouldFocus = false) {
      const clean = truncateToMaxWords(text, MAX_WORDS_PER_MESSAGE);
      if (!clean || !ws || ws.readyState !== WebSocket.OPEN) return;
      ws.send(JSON.stringify({
        type: 'message',
        user: username,
        text: clean
      }));

      msgInput.value = '';
      // Only focus if explicitly requested (not for emoji sends)
      if (shouldFocus) {
        msgInput.focus();
      }
    }

    function sendMessage() {
      // When sending from the input, we're already focused so keep focus
      const wasFocused = document.activeElement === msgInput;
      sendText(msgInput.value, wasFocused);
    }

    function sanitizeEmoji(val) {
      const s = String(val || '').trim().slice(0, 8);
      return s || '‚≠ê';
    }

    function setCustomEmoji(val) {
      customEmoji = sanitizeEmoji(val);
      if (customEmojiBtn) {
        customEmojiBtn.textContent = customEmoji;
        customEmojiBtn.dataset.emoji = customEmoji;
      }
    }

    function getFeedbackSubmittedKey() {
      const server = (localStorage.getItem('livechat_server') || serverInput.value || '').trim();
      return `livechat_feedback_submitted:${server}:cycle:${feedbackCycleId || 0}`;
    }

    function setStarsUI(rating) {
      const r = parseInt(rating, 10) || 0;
      if (!feedbackStars) return;
      feedbackStars.querySelectorAll('.star-btn').forEach(btn => {
        const v = parseInt(btn.dataset.value, 10);
        btn.classList.toggle('filled', v <= r);
      });
    }

    function updateFeedbackWordCount() {
      if (!feedbackWordCount || !feedbackText) return;
      const words = countWords(feedbackText.value);
      feedbackWordCount.textContent = `${Math.min(words, MAX_WORDS_FEEDBACK)}/${MAX_WORDS_FEEDBACK} words`;
    }

    function showFeedbackOverlay() {
      if (!feedbackOverlay) return;
      feedbackOverlay.classList.add('visible');
      feedbackOverlay.setAttribute('aria-hidden', 'false');
      // Block chat input while feedback is required
      msgInput.disabled = true;
      sendBtn.disabled = true;
      if (feedbackError) feedbackError.textContent = '';
    }

    function hideFeedbackOverlay() {
      if (!feedbackOverlay) return;
      feedbackOverlay.classList.remove('visible');
      feedbackOverlay.setAttribute('aria-hidden', 'true');
      msgInput.disabled = false;
      sendBtn.disabled = false;
    }

    function updateFeedbackOverlay() {
      if (!chatPanel.classList.contains('visible')) return;
      if (!enableFeedbackForm) {
        hideFeedbackOverlay();
        return;
      }
      const submitted = localStorage.getItem(getFeedbackSubmittedKey()) === '1';
      if (submitted) {
        hideFeedbackOverlay();
      } else {
        showFeedbackOverlay();
      }
    }

    async function submitFeedback() {
      if (!enableFeedbackForm) return;
      if (!selectedRating || selectedRating < 1 || selectedRating > 5) {
        if (feedbackError) feedbackError.textContent = 'Please select a rating.';
        return;
      }

      const comment = truncateToMaxWords(feedbackText ? feedbackText.value : '', MAX_WORDS_FEEDBACK);
      if (feedbackText && feedbackText.value !== comment) {
        feedbackText.value = comment;
        updateFeedbackWordCount();
      }

      if (feedbackSubmit) feedbackSubmit.disabled = true;
      if (feedbackError) feedbackError.textContent = '';

      try {
        const resp = await fetch('/feedback', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            rating: selectedRating,
            comment,
            cycleId: feedbackCycleId || 0,
            sessionCode: sessionCode || ''
          })
        });

        // If already submitted by IP, treat as done and return to chat.
        if (resp.status === 409) {
          localStorage.setItem(getFeedbackSubmittedKey(), '1');
          hideFeedbackOverlay();
          return;
        }

        if (!resp.ok) {
          let err = 'Submit failed. Try again.';
          try {
            const j = await resp.json();
            if (j && j.error) err = String(j.error);
          } catch (_) {}
          if (feedbackError) feedbackError.textContent = err;
          return;
        }

        localStorage.setItem(getFeedbackSubmittedKey(), '1');
        hideFeedbackOverlay();
      } catch (e) {
        if (feedbackError) feedbackError.textContent = 'Network error. Try again.';
      } finally {
        if (feedbackSubmit) feedbackSubmit.disabled = false;
      }
    }

    function addMessage(id, user, text, isOwn = false) {
      // Remove empty state if present
      const emptyState = messagesContainer.querySelector('.empty-state');
      if (emptyState) emptyState.remove();

      const msgEl = document.createElement('div');
      msgEl.className = 'msg' + (isOwn ? ' own' : '');
      msgEl.dataset.msgId = id;
      msgEl.innerHTML = `<span class="user" style="color: ${getUserColor(user)}">${escapeHtml(user)}:</span><span class="text">${escapeHtml(text)}</span>`;
      
      messagesContainer.appendChild(msgEl);
      messagesContainer.scrollTop = messagesContainer.scrollHeight;

      // Limit messages shown
      while (messagesContainer.children.length > 50) {
        messagesContainer.firstChild.remove();
      }
    }

    function removeMessage(msgId) {
      const msgEl = messagesContainer.querySelector(`[data-msg-id="${msgId}"]`);
      if (msgEl) {
        msgEl.style.transition = 'opacity 0.3s, transform 0.3s';
        msgEl.style.opacity = '0';
        msgEl.style.transform = 'translateX(-20px)';
        setTimeout(() => {
          msgEl.remove();
          // Show empty state if no messages left
          if (messagesContainer.querySelectorAll('.msg').length === 0) {
            messagesContainer.innerHTML = '<div class="empty-state">Send your first message! This will be visible to everyone.</div>';
          }
        }, 300);
      }
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Generate consistent color for username (same algorithm as overlay)
    function getUserColor(username) {
      let hash = 0;
      for (let i = 0; i < username.length; i++) {
        hash = username.charCodeAt(i) + ((hash << 5) - hash);
        hash = hash & hash;
      }
      const hue = Math.abs(hash) % 360;
      // Muted colors for theatre use (avoid vibrant user hues)
      const saturation = 28 + (Math.abs(hash >> 8) % 10);
      const lightness = 56 + (Math.abs(hash >> 16) % 10);
      return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
    }

    // Event listeners
    connectBtn.onclick = connect;
    sendBtn.onclick = sendMessage;

    // Feedback listeners
    if (feedbackStars) {
      feedbackStars.addEventListener('click', (e) => {
        const btn = e.target && e.target.closest ? e.target.closest('.star-btn[data-value]') : null;
        if (!btn) return;
        selectedRating = parseInt(btn.dataset.value, 10) || 0;
        setStarsUI(selectedRating);
        if (feedbackError) feedbackError.textContent = '';
      });
    }
    if (feedbackText) {
      feedbackText.addEventListener('input', () => {
        // IMPORTANT: Don't normalize/trim while the user is typing, otherwise
        // trailing spaces disappear and it feels like you can't type spaces.
        // Only enforce the max word limit when exceeded.
        const raw = String(feedbackText.value || '');
        const words = raw.trim().split(/\s+/).filter(Boolean);
        if (words.length > MAX_WORDS_FEEDBACK) {
          feedbackText.value = words.slice(0, MAX_WORDS_FEEDBACK).join(' ');
        }
        updateFeedbackWordCount();
      });
      updateFeedbackWordCount();
    }
    if (feedbackSubmit) {
      feedbackSubmit.onclick = submitFeedback;
    }

    // Emoji bar: send or insert based on setting
    // Use touchend for touch devices to prevent keyboard issues
    if (emojiBar) {
      let emojiTouchHandled = false;
      
      function processEmoji(emoji) {
        // Blur any active input first to dismiss keyboard
        if (document.activeElement && document.activeElement !== document.body) {
          document.activeElement.blur();
        }
        
        if (emojiDirectSend) {
          // Send emoji without focusing input
          sendText(emoji, false);
        } else {
          // Insert emoji into text box without focusing
          if (msgInput) {
            const val = msgInput.value || '';
            msgInput.value = val + emoji;
          }
        }
      }
      
      // Handle touch devices
      emojiBar.addEventListener('touchend', (e) => {
        const btn = e.target && e.target.closest ? e.target.closest('button[data-emoji]') : null;
        if (!btn) return;
        e.preventDefault();
        e.stopPropagation();
        emojiTouchHandled = true;
        processEmoji(btn.dataset.emoji);
        // Reset flag after a short delay
        setTimeout(() => { emojiTouchHandled = false; }, 100);
      }, { passive: false });
      
      // Handle mouse clicks (desktop fallback)
      emojiBar.addEventListener('click', (e) => {
        if (emojiTouchHandled) return; // Already handled by touch
        const btn = e.target && e.target.closest ? e.target.closest('button[data-emoji]') : null;
        if (!btn) return;
        e.preventDefault();
        e.stopPropagation();
        processEmoji(btn.dataset.emoji);
      });
      
      // Prevent touchstart from causing focus
      emojiBar.addEventListener('touchstart', (e) => {
        if (e.target && e.target.closest && e.target.closest('button[data-emoji]')) {
          e.preventDefault();
        }
      }, { passive: false });
    }

    msgInput.onkeypress = (e) => {
      if (e.key === 'Enter') sendMessage();
    };

    serverInput.onkeypress = (e) => {
      if (e.key === 'Enter') nameInput.focus();
    };

    nameInput.onkeypress = (e) => {
      if (e.key === 'Enter') connect();
    };

    // Prevent zoom on double tap (but not on inputs)
    let lastTouchEnd = 0;
    document.addEventListener('touchend', (e) => {
      const now = Date.now();
      if (now - lastTouchEnd <= 300) {
        // Only prevent double-tap zoom, not single taps
        if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'BUTTON' && e.target.tagName !== 'TEXTAREA') {
          e.preventDefault();
        }
      }
      lastTouchEnd = now;
    }, { passive: false });
    
    // Reconnect when page becomes visible (user unlocks phone / switches back to tab)
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'visible') {
        // Check if we should be connected but aren't
        if (chatPanel.classList.contains('visible') && lastServerAddress && username) {
          if (!ws || ws.readyState !== WebSocket.OPEN) {
            // Connection was lost while page was hidden, reconnect
            reconnectAttempts = 0; // Reset attempts since user is actively returning
            attemptReconnect();
          }
        }
      }
    });
    
    // Also try to reconnect on focus (some browsers don't fire visibilitychange)
    window.addEventListener('focus', () => {
      if (chatPanel.classList.contains('visible') && lastServerAddress && username) {
        if (!ws || ws.readyState !== WebSocket.OPEN) {
          reconnectAttempts = 0;
          attemptReconnect();
        }
      }
    });
  </script>
</body>
</html>
