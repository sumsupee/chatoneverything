<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, user-scalable=no, interactive-widget=resizes-content">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Chat on Everything Controller</title>
    <link rel="icon" href="/assets/title_plain.png" type="image/png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&family=Outfit:wght@400;500;600&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="/css/mobile.css">
</head>

<body>
    <div id="app">
        <header>
            <h1>Chat on Everything</h1>
            <p>Send messages to the screen</p>
            <div class="status">
                <span class="status-dot" id="status-dot"></span>
                <span id="status-text">Disconnected</span>
            </div>
        </header>

        <!-- Connection Panel -->
        <div id="connect-panel">
            <div class="form-group">
                <label>Your Name</label>
                <input type="text" id="name-input" placeholder="Enter your display name" autocomplete="off">
            </div>
            <div class="error" id="connect-error"></div>
            <button class="btn btn-primary" id="connect-btn">Connect</button>
        </div>

        <!-- Chat Panel -->
        <div id="chat-panel">
            <div id="messages">
                <div class="empty-state">
                    Send your first message! This will be visible to everyone.
                </div>
            </div>
            <div id="input-area">
                <div id="emoji-bar" aria-label="Reactions">
                    <button class="emoji-btn" type="button" data-emoji="üòÇ" aria-label="Laugh">üòÇ</button>
                    <button class="emoji-btn" type="button" data-emoji="‚ù§Ô∏è" aria-label="Love">‚ù§Ô∏è</button>
                    <button class="emoji-btn" type="button" data-emoji="üëç" aria-label="Thumbs up">üëç</button>
                    <button class="emoji-btn" type="button" data-emoji="üëé" aria-label="Boo">üëé</button>
                    <button class="emoji-btn" type="button" data-emoji="üòÆ" aria-label="Wow">üòÆ</button>
                    <button class="emoji-btn" type="button" data-emoji="üò¢" aria-label="Cry">üò¢</button>
                    <button class="emoji-btn" type="button" id="custom-emoji-btn" data-emoji="‚≠ê"
                        aria-label="Custom reaction">‚≠ê</button>
                </div>
                <div class="input-row">
                    <input type="text" id="msg-input" placeholder="Type a message..." autocomplete="off">
                    <button id="send-btn">‚û§</button>
                </div>
            </div>

            <!-- Feedback overlay (shown when enabled by admin) -->
            <div id="feedback-overlay" aria-hidden="true">
                <div class="feedback-card" role="dialog" aria-modal="true" aria-label="Feedback form">
                    <div class="feedback-title">Rate the event</div>
                    <div class="stars" id="feedback-stars" role="radiogroup" aria-label="Rate the event (1 to 5 stars)">
                        <button class="star-btn" type="button" data-value="1" aria-label="1 star">‚òÖ</button>
                        <button class="star-btn" type="button" data-value="2" aria-label="2 stars">‚òÖ</button>
                        <button class="star-btn" type="button" data-value="3" aria-label="3 stars">‚òÖ</button>
                        <button class="star-btn" type="button" data-value="4" aria-label="4 stars">‚òÖ</button>
                        <button class="star-btn" type="button" data-value="5" aria-label="5 stars">‚òÖ</button>
                    </div>
                    <textarea id="feedback-text" placeholder="Optional: tell us anything (max 150 words)"></textarea>
                    <div class="feedback-meta">
                        <div id="feedback-word-count">0/150 words</div>
                        <div id="feedback-error"></div>
                    </div>
                    <button class="btn btn-primary" id="feedback-submit" type="button">Submit</button>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        import { $, normalizeWhitespace, countWords, truncateToMaxWords, escapeHtml, getUserColor } from '/js/utils.js';
        import { LiveChatClient } from '/js/websocket-client.js';

        // Elements
        const connectPanel = $('connect-panel');
        const chatPanel = $('chat-panel');
        const nameInput = $('name-input');
        const connectBtn = $('connect-btn');
        const connectError = $('connect-error');
        const statusDot = $('status-dot');
        const statusText = $('status-text');
        const messagesContainer = $('messages');
        const msgInput = $('msg-input');
        const sendBtn = $('send-btn');
        const emojiBar = $('emoji-bar');
        const customEmojiBtn = $('custom-emoji-btn');
        const feedbackOverlay = $('feedback-overlay');
        const feedbackStars = $('feedback-stars');
        const feedbackText = $('feedback-text');
        const feedbackSubmit = $('feedback-submit');
        const feedbackError = $('feedback-error');
        const feedbackWordCount = $('feedback-word-count');



        let chatClient = null;
        let username = '';
        let sessionCode = '';
        let urlSessionCode = ''; // Session code from URL
        let disableChatHistory = true; // Default: only show own messages
        let serverAddress = ''; // Hidden server address (not shown to user)

        // Extract session code from URL query parameter
        function getSessionCodeFromUrl() {
            try {
                const params = new URLSearchParams(window.location.search);
                return params.get('s') || '';
            } catch (e) {
                return '';
            }
        }
        urlSessionCode = getSessionCodeFromUrl();
        let customEmoji = '‚≠ê';
        let emojiDirectSend = true; // When true, emoji buttons send directly; when false, insert into text box
        let slowModeEnabled = false;
        let slowModeSeconds = 3;
        const MAX_WORDS_PER_MESSAGE = 50;

        // Reconnection state removed (handled by LiveChatClient)
        // let reconnectAttempts = 0; ...
        let lastServerAddress = '';
        const MAX_WORDS_FEEDBACK = 150;

        let enableFeedbackForm = false;
        let feedbackCycleId = 0;
        let selectedRating = 0;

        // Detect if page is served over HTTPS (secure tunnel)
        const isSecure = window.location.protocol === 'https:';

        // Load saved values
        // Check if we're accessing via local URL - if so, ALWAYS use local WebSocket
        const isLocalUrl = !isSecure &&
            (window.location.hostname === 'localhost' ||
                window.location.hostname.match(/^(10\.|172\.(1[6-9]|2[0-9]|3[01])\.|192\.168\.)/) ||
                !window.location.hostname.includes('.') ||
                window.location.hostname.endsWith('.local'));

        // Check if default WebSocket URL was injected
        if (window.__defaultWsUrl) {
            serverAddress = window.__defaultWsUrl;
            // For local URLs, always override localStorage to ensure local WebSocket is used
            if (isLocalUrl) {
                localStorage.setItem('livechat_server', window.__defaultWsUrl);
            } else {
                localStorage.setItem('livechat_server', window.__defaultWsUrl);
            }
        } else if (isLocalUrl) {
            // Force local WebSocket for local URLs, regardless of localStorage
            const localWsUrl = window.location.hostname + ':8765';
            serverAddress = localWsUrl;
            localStorage.setItem('livechat_server', localWsUrl);
        } else {
            serverAddress = localStorage.getItem('livechat_server') || '';
        }
        nameInput.value = localStorage.getItem('livechat_name') || '';

        // Auto-detect server from URL if accessed from same network
        if (!serverAddress && window.location.hostname !== 'localhost') {
            if (isSecure) {
                // For HTTPS tunnel, check meta tag for default WebSocket URL
                const metaTag = document.querySelector('meta[name="default-ws-url"]');
                if (metaTag && metaTag.content) {
                    serverAddress = metaTag.content;
                    localStorage.setItem('livechat_server', metaTag.content);
                }
            } else {
                serverAddress = window.location.hostname + ':8765';
            }
        }

        // Auto-connect if name is saved
        if (serverAddress && nameInput.value && urlSessionCode) {
            connect();
        }

        function setStatus(connected, text) {
            statusDot.classList.toggle('connected', connected);
            statusText.textContent = text;
        }

        function showError(msg) {
            connectError.textContent = msg;
        }

        function clearError() {
            connectError.textContent = '';
        }


        function connect() {
            const server = serverAddress.trim();
            const name = nameInput.value.trim();

            if (!server) {
                showError('Server address not configured');
                return;
            }
            if (!name) {
                showError('Please enter your name');
                return;
            }

            clearError();
            connectBtn.disabled = true;
            connectBtn.textContent = 'Connecting...';
            setStatus(false, 'Connecting...');

            // Save values
            localStorage.setItem('livechat_server', server);
            localStorage.setItem('livechat_name', name);

            username = name;
            lastServerAddress = server;

            let wsUrl = LiveChatClient.getWebSocketUrl(server);

            if (chatClient) {
                chatClient.disconnect();
            }

            chatClient = new LiveChatClient({
                onOpen: () => {
                    setStatus(false, 'Joining session...');
                    chatClient.send({ type: 'join', sessionCode: urlSessionCode });
                },
                onMessage: handleWebSocketMessage,
                onClose: () => {
                    setStatus(false, 'Disconnected');
                    if (chatPanel.classList.contains('visible')) {
                        // The client handles its own reconnect scheduling implicitly if connection drops,
                        // but if we need UI updates or specific logic on close, we do it here.
                        // LiveChatClient auto-reconnects by default unless disconnected explicitly.
                    }
                    connectBtn.disabled = false;
                    connectBtn.textContent = 'Connect';
                },
                onError: (err) => {
                    showError('Connection failed. Check server address.');
                    connectBtn.disabled = false;
                    connectBtn.textContent = 'Connect';
                    setStatus(false, 'Connection failed');
                },
                onStatusChange: (connected, text) => {
                    setStatus(connected, text);
                }
            });

            chatClient.connect(wsUrl);
        }

        function handleWebSocketMessage(event) {
            try {
                const data = JSON.parse(event.data);

                if (data.type === 'join-result') {
                    if (data.success) {
                        sessionCode = data.code || urlSessionCode;
                        setStatus(true, 'Connected');
                        connectPanel.classList.add('hidden');
                        chatPanel.classList.add('visible');
                        // reconnectAttempts and startHeartbeat handled by LiveChatClient
                        updateFeedbackOverlay();
                    } else {
                        // Session code invalid - redirect to join page
                        setStatus(false, 'Session not found');
                        showError('Session not found. The event may have ended.');
                        connectBtn.disabled = false;
                        connectBtn.textContent = 'Connect';
                        // Redirect to base URL to show join page
                        setTimeout(() => {
                            window.location.href = '/';
                        }, 2000);
                    }
                } else if (data.type === 'error') {
                    if (data.error === 'session_not_validated') {
                        // Session was not validated - resend join request
                        chatClient.send({ type: 'join', sessionCode: urlSessionCode });
                    }
                } else if (data.type === 'session') {
                    sessionCode = data.code;
                    updateFeedbackOverlay();
                } else if (data.type === 'blocked') {
                    // Server rejected messages from this IP.
                    setStatus(false, 'Blocked');
                    msgInput.disabled = true;
                    sendBtn.disabled = true;
                    // Show a notice in the chat panel.
                    const emptyState = messagesContainer.querySelector('.empty-state');
                    if (emptyState) emptyState.remove();
                    const notice = document.createElement('div');
                    notice.className = 'empty-state';
                    notice.textContent = 'You have been blocked by the admin. You can no longer send messages from this network/IP.';
                    messagesContainer.appendChild(notice);
                } else if (data.type === 'slow-mode') {
                    showSlowModeNotice(data.remainingSeconds || 1);
                } else if (data.type === 'message') {
                    if (data.id !== undefined && data.user && data.text) {
                        const isOwn = data.user === username;
                        // If chat history is disabled for others, only show own messages
                        if (!disableChatHistory || isOwn) {
                            addMessage(data.id, data.user, data.text, isOwn);
                        }
                    }
                } else if (data.type === 'message-deleted') {
                    if (data.msgId !== undefined) {
                        removeMessage(data.msgId);
                    }
                } else if (data.type === 'settings-sync') {
                    if (data.settings) {
                        if (data.settings.disableChatHistory !== undefined) {
                            disableChatHistory = data.settings.disableChatHistory;
                        }
                        if (data.settings.customEmoji !== undefined) {
                            setCustomEmoji(data.settings.customEmoji);
                        }
                        if (data.settings.emojiDirectSend !== undefined) {
                            emojiDirectSend = !!data.settings.emojiDirectSend;
                        }
                        if (data.settings.slowModeEnabled !== undefined) {
                            slowModeEnabled = !!data.settings.slowModeEnabled;
                        }
                        if (data.settings.slowModeSeconds !== undefined) {
                            slowModeSeconds = parseInt(data.settings.slowModeSeconds, 10) || 3;
                        }
                        if (data.settings.enableFeedbackForm !== undefined) {
                            enableFeedbackForm = !!data.settings.enableFeedbackForm;
                        }
                        if (data.settings.feedbackCycleId !== undefined) {
                            const prevCycle = feedbackCycleId;
                            feedbackCycleId = parseInt(data.settings.feedbackCycleId, 10) || 0;
                            if (feedbackCycleId !== prevCycle) {
                                selectedRating = 0;
                                setStarsUI(0);
                                if (feedbackText) feedbackText.value = '';
                                updateFeedbackWordCount();
                            }
                        }
                        updateFeedbackOverlay();
                    }
                    // Autofill WebSocket URL if provided and field is empty or contains local network address
                    if (data.wsUrl) {
                        const currentValue = serverAddress.trim();
                        // Check if current value is a local network address or empty
                        const isLocalNetwork = !currentValue || /^(10\.|172\.(1[6-9]|2[0-9]|3[01])\.|192\.168\.|localhost|127\.|.*:8765$)/.test(currentValue);
                        // Prefer Cloudflare URLs over local addresses
                        const isCloudflareUrl = data.wsUrl.includes('trycloudflare.com');

                        if (isLocalNetwork || (isCloudflareUrl && !currentValue.includes('trycloudflare.com'))) {
                            // Extract hostname from ws:// or wss:// URL (remove protocol, keep hostname:port if present)
                            let extractedUrl = data.wsUrl;
                            // Remove ws:// or wss:// prefix
                            extractedUrl = extractedUrl.replace(/^wss?:\/\//, '');
                            // Remove trailing slash if present
                            extractedUrl = extractedUrl.replace(/\/$/, '');

                            if (extractedUrl) {
                                serverAddress = extractedUrl;
                                localStorage.setItem('livechat_server', serverAddress);
                                console.log('Autofilled WebSocket URL:', extractedUrl);
                            }
                        }
                    }
                }
                // Ignore other message types (including 'pong' responses)
            } catch (e) {
                console.error('Error handling message:', e);
            }
        }

        function disconnect(showUI = true) {
            if (chatClient) {
                chatClient.disconnect();
            }
            if (showUI) {
                chatPanel.classList.remove('visible');
                connectPanel.classList.remove('hidden');
                setStatus(false, 'Disconnected');
                hideFeedbackOverlay();
                // Clear messages
                messagesContainer.innerHTML = '<div class="empty-state">Send your first message! This will be visible to everyone.</div>';
            }
        }



        let slowModeNoticeTimeout = null;

        function showSlowModeNotice(seconds) {
            // Show a temporary notice in the center of the screen
            let notice = document.getElementById('slow-mode-notice');
            if (!notice) {
                notice = document.createElement('div');
                notice.id = 'slow-mode-notice';
                notice.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(176,138,70,0.98);color:#fff;padding:16px 28px;border-radius:14px;font:600 16px "Outfit",sans-serif;z-index:9999;box-shadow:0 6px 24px rgba(0,0,0,0.5);text-align:center;';
                document.body.appendChild(notice);
            }
            notice.textContent = `Slow mode: wait ${seconds}s`;
            notice.style.display = 'block';
            if (slowModeNoticeTimeout) clearTimeout(slowModeNoticeTimeout);
            slowModeNoticeTimeout = setTimeout(() => {
                notice.style.display = 'none';
            }, 2500);
        }

        function sendText(text, shouldFocus = false) {
            const clean = truncateToMaxWords(text, MAX_WORDS_PER_MESSAGE);
            if (!clean) return;

            if (chatClient) {
                chatClient.send({
                    type: 'message',
                    user: username,
                    text: clean
                });
            }

            msgInput.value = '';
            // Only focus if explicitly requested (not for emoji sends)
            if (shouldFocus) {
                msgInput.focus();
            }
        }

        function sendMessage() {
            // When sending from the input, we're already focused so keep focus
            const wasFocused = document.activeElement === msgInput;
            sendText(msgInput.value, wasFocused);
        }

        function sanitizeEmoji(val) {
            const s = String(val || '').trim().slice(0, 8);
            return s || '‚≠ê';
        }

        function setCustomEmoji(val) {
            customEmoji = sanitizeEmoji(val);
            if (customEmojiBtn) {
                customEmojiBtn.textContent = customEmoji;
                customEmojiBtn.dataset.emoji = customEmoji;
            }
        }

        function getFeedbackSubmittedKey() {
            const server = (localStorage.getItem('livechat_server') || serverAddress || '').trim();
            return `livechat_feedback_submitted:${server}:cycle:${feedbackCycleId || 0}`;
        }

        function setStarsUI(rating) {
            const r = parseInt(rating, 10) || 0;
            if (!feedbackStars) return;
            feedbackStars.querySelectorAll('.star-btn').forEach(btn => {
                const v = parseInt(btn.dataset.value, 10);
                btn.classList.toggle('filled', v <= r);
            });
        }

        function updateFeedbackWordCount() {
            if (!feedbackWordCount || !feedbackText) return;
            const words = countWords(feedbackText.value);
            feedbackWordCount.textContent = `${Math.min(words, MAX_WORDS_FEEDBACK)}/${MAX_WORDS_FEEDBACK} words`;
        }

        function showFeedbackOverlay() {
            if (!feedbackOverlay) return;
            feedbackOverlay.classList.add('visible');
            feedbackOverlay.setAttribute('aria-hidden', 'false');
            // Block chat input while feedback is required
            msgInput.disabled = true;
            sendBtn.disabled = true;
            if (feedbackError) feedbackError.textContent = '';
        }

        function hideFeedbackOverlay() {
            if (!feedbackOverlay) return;
            feedbackOverlay.classList.remove('visible');
            feedbackOverlay.setAttribute('aria-hidden', 'true');
            msgInput.disabled = false;
            sendBtn.disabled = false;
        }

        function updateFeedbackOverlay() {
            if (!chatPanel.classList.contains('visible')) return;
            if (!enableFeedbackForm) {
                hideFeedbackOverlay();
                return;
            }
            const submitted = localStorage.getItem(getFeedbackSubmittedKey()) === '1';
            if (submitted) {
                hideFeedbackOverlay();
            } else {
                showFeedbackOverlay();
            }
        }

        async function submitFeedback() {
            if (!enableFeedbackForm) return;
            if (!selectedRating || selectedRating < 1 || selectedRating > 5) {
                if (feedbackError) feedbackError.textContent = 'Please select a rating.';
                return;
            }

            const comment = truncateToMaxWords(feedbackText ? feedbackText.value : '', MAX_WORDS_FEEDBACK);
            if (feedbackText && feedbackText.value !== comment) {
                feedbackText.value = comment;
                updateFeedbackWordCount();
            }

            if (feedbackSubmit) feedbackSubmit.disabled = true;
            if (feedbackError) feedbackError.textContent = '';

            try {
                const resp = await fetch('/feedback', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        rating: selectedRating,
                        comment,
                        cycleId: feedbackCycleId || 0,
                        sessionCode: sessionCode || ''
                    })
                });

                // If already submitted by IP, treat as done and return to chat.
                if (resp.status === 409) {
                    localStorage.setItem(getFeedbackSubmittedKey(), '1');
                    hideFeedbackOverlay();
                    return;
                }

                if (!resp.ok) {
                    let err = 'Submit failed. Try again.';
                    try {
                        const j = await resp.json();
                        if (j && j.error) err = String(j.error);
                    } catch (_) { }
                    if (feedbackError) feedbackError.textContent = err;
                    return;
                }

                localStorage.setItem(getFeedbackSubmittedKey(), '1');
                hideFeedbackOverlay();
            } catch (e) {
                if (feedbackError) feedbackError.textContent = 'Network error. Try again.';
            } finally {
                if (feedbackSubmit) feedbackSubmit.disabled = false;
            }
        }

        function addMessage(id, user, text, isOwn = false) {
            // Remove empty state if present
            const emptyState = messagesContainer.querySelector('.empty-state');
            if (emptyState) emptyState.remove();

            const msgEl = document.createElement('div');
            msgEl.className = 'msg' + (isOwn ? ' own' : '');
            msgEl.dataset.msgId = id;
            msgEl.innerHTML = `<span class="user" style="color: ${getUserColor(user)}">${escapeHtml(user)}:</span><span class="text">${escapeHtml(text)}</span>`;

            messagesContainer.appendChild(msgEl);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;

            // Limit messages shown
            while (messagesContainer.children.length > 50) {
                messagesContainer.firstChild.remove();
            }
        }

        function removeMessage(msgId) {
            const msgEl = messagesContainer.querySelector(`[data-msg-id="${msgId}"]`);
            if (msgEl) {
                msgEl.style.transition = 'opacity 0.3s, transform 0.3s';
                msgEl.style.opacity = '0';
                msgEl.style.transform = 'translateX(-20px)';
                setTimeout(() => {
                    msgEl.remove();
                    // Show empty state if no messages left
                    if (messagesContainer.querySelectorAll('.msg').length === 0) {
                        messagesContainer.innerHTML = '<div class="empty-state">Send your first message! This will be visible to everyone.</div>';
                    }
                }, 300);
            }
        }



        // Event listeners
        connectBtn.onclick = connect;
        sendBtn.onclick = sendMessage;

        // Feedback listeners
        if (feedbackStars) {
            feedbackStars.addEventListener('click', (e) => {
                const btn = e.target && e.target.closest ? e.target.closest('.star-btn[data-value]') : null;
                if (!btn) return;
                selectedRating = parseInt(btn.dataset.value, 10) || 0;
                setStarsUI(selectedRating);
                if (feedbackError) feedbackError.textContent = '';
            });
        }
        if (feedbackText) {
            feedbackText.addEventListener('input', () => {
                // IMPORTANT: Don't normalize/trim while the user is typing, otherwise
                // trailing spaces disappear and it feels like you can't type spaces.
                // Only enforce the max word limit when exceeded.
                const raw = String(feedbackText.value || '');
                const words = raw.trim().split(/\s+/).filter(Boolean);
                if (words.length > MAX_WORDS_FEEDBACK) {
                    feedbackText.value = words.slice(0, MAX_WORDS_FEEDBACK).join(' ');
                }
                updateFeedbackWordCount();
            });
            updateFeedbackWordCount();
        }
        if (feedbackSubmit) {
            feedbackSubmit.onclick = submitFeedback;
        }

        // Emoji bar: send or insert based on setting
        // Use touchend for touch devices to prevent keyboard issues
        if (emojiBar) {
            let emojiTouchHandled = false;

            function processEmoji(emoji) {
                // Blur any active input first to dismiss keyboard
                if (document.activeElement && document.activeElement !== document.body) {
                    document.activeElement.blur();
                }

                if (emojiDirectSend) {
                    // Send emoji without focusing input
                    sendText(emoji, false);
                } else {
                    // Insert emoji into text box without focusing
                    if (msgInput) {
                        const val = msgInput.value || '';
                        msgInput.value = val + emoji;
                    }
                }
            }

            // Handle touch devices
            emojiBar.addEventListener('touchend', (e) => {
                const btn = e.target && e.target.closest ? e.target.closest('button[data-emoji]') : null;
                if (!btn) return;
                e.preventDefault();
                e.stopPropagation();
                emojiTouchHandled = true;
                processEmoji(btn.dataset.emoji);
                // Reset flag after a short delay
                setTimeout(() => { emojiTouchHandled = false; }, 100);
            }, { passive: false });

            // Handle mouse clicks (desktop fallback)
            emojiBar.addEventListener('click', (e) => {
                if (emojiTouchHandled) return; // Already handled by touch
                const btn = e.target && e.target.closest ? e.target.closest('button[data-emoji]') : null;
                if (!btn) return;
                e.preventDefault();
                e.stopPropagation();
                processEmoji(btn.dataset.emoji);
            });

            // Prevent touchstart from causing focus
            emojiBar.addEventListener('touchstart', (e) => {
                if (e.target && e.target.closest && e.target.closest('button[data-emoji]')) {
                    e.preventDefault();
                }
            }, { passive: false });
        }

        msgInput.onkeypress = (e) => {
            if (e.key === 'Enter') sendMessage();
        };

        nameInput.onkeypress = (e) => {
            if (e.key === 'Enter') connect();
        };

        // Prevent zoom on double tap (but not on inputs)
        let lastTouchEnd = 0;
        document.addEventListener('touchend', (e) => {
            const now = Date.now();
            if (now - lastTouchEnd <= 300) {
                // Only prevent double-tap zoom, not single taps
                if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'BUTTON' && e.target.tagName !== 'TEXTAREA') {
                    e.preventDefault();
                }
            }
            lastTouchEnd = now;
        }, { passive: false });

        // Reconnect when page becomes visible (user unlocks phone / switches back to tab)
        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'visible') {
                // Check if we should be connected but aren't
                if (chatPanel.classList.contains('visible') && lastServerAddress && username) {
                    if (!ws || ws.readyState !== WebSocket.OPEN) {
                        // Connection was lost while page was hidden, reconnect
                        reconnectAttempts = 0; // Reset attempts since user is actively returning
                        attemptReconnect();
                    }
                }
            }
        });

        // Also try to reconnect on focus (some browsers don't fire visibilitychange)
        window.addEventListener('focus', () => {
            if (chatPanel.classList.contains('visible') && lastServerAddress && username) {
                if (!ws || ws.readyState !== WebSocket.OPEN) {
                    reconnectAttempts = 0;
                    attemptReconnect();
                }
            }
        });
    </script>
</body>

</html>